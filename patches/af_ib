Bottom: a714bc4ff96a4b6832ac8f7cb9d7f0d37f8320e7
Top:    887d55d9c4229530cb6672292eccba87095a9e52
Author: Sean Hefty <sean.hefty@intel.com>
Date:   2012-08-17 14:02:45 -0700

librdmacm: Enable AF_IB support

Signed-off-by: Sean Hefty <sean.hefty@intel.com>


---

diff --git a/include/rdma/rdma_cma.h b/include/rdma/rdma_cma.h
index 1487f8f..f3c8921 100755
--- a/include/rdma/rdma_cma.h
+++ b/include/rdma/rdma_cma.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2005 Voltaire Inc.  All rights reserved.
- * Copyright (c) 2005-2010 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2005-2012 Intel Corporation.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
@@ -581,19 +581,8 @@ int rdma_get_cm_event(struct rdma_event_channel *channel,
  */
 int rdma_ack_cm_event(struct rdma_cm_event *event);
 
-static inline uint16_t rdma_get_src_port(struct rdma_cm_id *id)
-{
-	return	id->route.addr.src_addr.sa_family == PF_INET6 ?
-		id->route.addr.src_sin6.sin6_port :
-		id->route.addr.src_sin.sin_port;
-}
-
-static inline uint16_t rdma_get_dst_port(struct rdma_cm_id *id)
-{
-	return	id->route.addr.dst_addr.sa_family == PF_INET6 ?
-		id->route.addr.dst_sin6.sin6_port :
-		id->route.addr.dst_sin.sin_port;
-}
+uint16_t rdma_get_src_port(struct rdma_cm_id *id);
+uint16_t rdma_get_dst_port(struct rdma_cm_id *id);
 
 static inline struct sockaddr *rdma_get_local_addr(struct rdma_cm_id *id)
 {
diff --git a/src/acm.c b/src/acm.c
index d96dbcd..92411fa 100755
--- a/src/acm.c
+++ b/src/acm.c
@@ -324,6 +324,17 @@ static void ucma_copy_rai_addr(struct acm_ep_addr_data *data, struct sockaddr *a
 	}
 }
 
+static int ucma_inet_addr(struct sockaddr *addr, socklen_t len)
+{
+	return len && addr && (addr->sa_family == AF_INET ||
+			       addr->sa_family == AF_INET6);
+}
+
+static int ucma_ib_addr(struct sockaddr *addr, socklen_t len)
+{
+	return len && addr && (addr->sa_family == AF_IB);
+}
+
 void ucma_ib_resolve(struct rdma_addrinfo **rai, struct rdma_addrinfo *hints)
 {
 	cma_acm_msg_t msg;
@@ -340,14 +351,14 @@ void ucma_ib_resolve(struct rdma_addrinfo **rai, struct rdma_addrinfo *hints)
 	msg.hdr.length = ACM_MSG_HDR_LENGTH;
 
 	data = &msg.resolve_data[0];
-	if ((*rai)->ai_src_len) {
+	if (ucma_inet_addr((*rai)->ai_src_addr, (*rai)->ai_src_len)) {
 		data->flags = ACM_EP_FLAG_SOURCE;
 		ucma_copy_rai_addr(data, (*rai)->ai_src_addr);
 		data++;
 		msg.hdr.length += ACM_MSG_EP_LENGTH;
 	}
 
-	if ((*rai)->ai_dst_len) {
+	if (ucma_inet_addr((*rai)->ai_dst_addr, (*rai)->ai_dst_len)) {
 		data->flags = ACM_EP_FLAG_DEST;
 		if ((*rai)->ai_flags & (RAI_NUMERICHOST | RAI_NOROUTE))
 			data->flags |= ACM_FLAGS_NODELAY;
@@ -356,7 +367,9 @@ void ucma_ib_resolve(struct rdma_addrinfo **rai, struct rdma_addrinfo *hints)
 		msg.hdr.length += ACM_MSG_EP_LENGTH;
 	}
 
-	if (hints && hints->ai_route_len) {
+	if (hints && (hints->ai_route_len ||
+	    ucma_ib_addr((*rai)->ai_src_addr, (*rai)->ai_src_len) ||
+	    ucma_ib_addr((*rai)->ai_dst_addr, (*rai)->ai_dst_len))) {
 		struct ibv_path_record *path;
 
 		if (hints->ai_route_len == sizeof(struct ibv_path_record))
@@ -366,12 +379,20 @@ void ucma_ib_resolve(struct rdma_addrinfo **rai, struct rdma_addrinfo *hints)
 		else
 			path = NULL;
 
-		if (path) {
-			data->type = ACM_EP_INFO_PATH;
+		if (path)
 			memcpy(&data->info.path, path, sizeof(*path));
-			data++;
-			msg.hdr.length += ACM_MSG_EP_LENGTH;
+
+		if (ucma_ib_addr((*rai)->ai_src_addr, (*rai)->ai_src_len)) {
+			memcpy(&data->info.path.sgid,
+			       &((struct sockaddr_ib *) (*rai)->ai_src_addr)->sib_addr, 16);
+		}
+		if (ucma_ib_addr((*rai)->ai_dst_addr, (*rai)->ai_dst_len)) {
+			memcpy(&data->info.path.dgid,
+			       &((struct sockaddr_ib *) (*rai)->ai_dst_addr)->sib_addr, 16);
 		}
+		data->type = ACM_EP_INFO_PATH;
+		data++;
+		msg.hdr.length += ACM_MSG_EP_LENGTH;
 	}
 
 	pthread_mutex_lock(&acm_lock);
@@ -389,7 +410,7 @@ void ucma_ib_resolve(struct rdma_addrinfo **rai, struct rdma_addrinfo *hints)
 	ucma_ib_save_resp(*rai, &msg);
 
 	if (af_ib_support && !((*rai)->ai_flags & RAI_ROUTEONLY) &&
-	    (*rai)->ai_route_len)
+	    (*rai)->ai_route_len && ((*rai)->ai_family != AF_IB))
 		ucma_resolve_af_ib(rai);
 }
 
diff --git a/src/cma.c b/src/cma.c
index 5280620..2994655 100755
--- a/src/cma.c
+++ b/src/cma.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005-2011 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2005-2012 Intel Corporation.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
@@ -185,9 +185,6 @@ static void ucma_set_af_ib_support(void)
 	struct sockaddr_ib sib;
 	int ret;
 
-	/* Just return - do not enable AF_IB support for now */
-	return;
-
 	ret = rdma_create_id(NULL, &id, NULL, RDMA_PS_IB);
 	if (ret)
 		return;
@@ -2242,3 +2239,28 @@ int ucma_max_qpsize(struct rdma_cm_id *id)
 	id_priv = container_of(id, struct cma_id_private, id);
 	return id_priv->cma_dev->max_qpsize;
 }
+
+static uint16_t ucma_get_port(struct sockaddr *addr)
+{
+	switch (addr->sa_family) {
+	case AF_INET:
+		return ((struct sockaddr_in *) addr)->sin_port;
+	case AF_INET6:
+		return ((struct sockaddr_in6 *) addr)->sin6_port;
+	case AF_IB:
+		return htons((uint16_t) ntohll(((struct sockaddr_ib *) addr)->sib_sid));
+	default:
+		return 0;
+	}
+}
+
+uint16_t rdma_get_src_port(struct rdma_cm_id *id)
+{
+	return ucma_get_port(&id->route.addr.src_addr);
+}
+
+uint16_t rdma_get_dst_port(struct rdma_cm_id *id)
+{
+	return ucma_get_port(&id->route.addr.dst_addr);
+}
+
diff --git a/src/librdmacm.map b/src/librdmacm.map
index d994de4..5c317a3 100644
--- a/src/librdmacm.map
+++ b/src/librdmacm.map
@@ -61,5 +61,7 @@ RDMACM_1.0 {
 		rfcntl;
 		rpoll;
 		rselect;
+		rdma_get_src_port;
+		rdma_get_dst_port;
 	local: *;
 };
