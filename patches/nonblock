Bottom: 7dce4c415b86085b4718701aa45fc9f061036ab1
Top:    2737e70c64c9617bb741fff20192947019c4f7d9
Author: Sean Hefty <sean.hefty@intel.com>
Date:   2013-02-19 20:03:58 -0800

rsocket: Fix resetting O_NONBLOCK after calling shutdown

Shutdown switches an rsocket from nonblocking to blocking to
ensure that all data has been sent.  After completing all
transfers, it should switch back to nonblocking; this handles
partial shutdown situations, where only half the connection
is shut down.  However, the code uses the value of '1' to
set the nonblocking flag, rather than O_NONBLOCK.  Fix this.

Signed-off-by: Sean Hefty <sean.hefty@intel.com>


---

diff --git a/src/rsocket.c b/src/rsocket.c
index 9b6c667..03f5dc4 100644
--- a/src/rsocket.c
+++ b/src/rsocket.c
@@ -3023,7 +3023,7 @@ int rshutdown(int socket, int how)
 		rs_process_cq(rs, 0, rs_conn_all_sends_done);
 
 	if ((rs->fd_flags & O_NONBLOCK) && (rs->state & rs_connected))
-		rs_set_nonblocking(rs, 1);
+		rs_set_nonblocking(rs, rs->fd_flags);
 
 	return 0;
 }
@@ -3040,7 +3040,7 @@ static void ds_shutdown(struct rsocket *rs)
 	ds_process_cqs(rs, 0, ds_all_sends_done);
 
 	if (rs->fd_flags & O_NONBLOCK)
-		rs_set_nonblocking(rs, 1);
+		rs_set_nonblocking(rs, rs->fd_flags);
 }
 
 int rclose(int socket)
