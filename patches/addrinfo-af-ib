Bottom: 4e01eb8a1c0681cd7bcca9c1bf3502036b929d4b
Top:    0fe9873298edf4cada887e75c401246a8cdab420
Author: Sean Hefty <sean.hefty@intel.com>
Date:   2012-08-28 12:33:04 -0700

librdmacm: Support using GIDs with rdma_getaddrinfo

Allow the user to specify a GID as the node parameter into
rdma_getaddrinfo.

To distinguish between the node being an IPv6 address or a GID,
we add a new flag, RAI_FAMILY, which can be set as part of the
hints to rdma_getaddrinfo.  When set, this flag indicates that the
value of ai_family in the hints should be used when interpretting
the node parameter.

Signed-off-by: Sean Hefty <sean.hefty@intel.com>


---

diff --git a/include/rdma/rdma_cma.h b/include/rdma/rdma_cma.h
index f3c8921..07fc747 100755
--- a/include/rdma/rdma_cma.h
+++ b/include/rdma/rdma_cma.h
@@ -176,6 +176,7 @@ struct rdma_cm_event {
 #define RAI_PASSIVE		0x00000001
 #define RAI_NUMERICHOST		0x00000002
 #define RAI_NOROUTE		0x00000004
+#define RAI_FAMILY		0x00000008
 
 struct rdma_addrinfo {
 	int			ai_flags;
diff --git a/man/rdma_getaddrinfo.3 b/man/rdma_getaddrinfo.3
index 86e00ca..cd819c6 100755
--- a/man/rdma_getaddrinfo.3
+++ b/man/rdma_getaddrinfo.3
@@ -48,6 +48,9 @@ If specified, then the node parameter, if provided, must be a numerical
 network address.  This flag suppresses any lengthy address resolution. 
 .IP "RAI_NOROUTE" 12
 If set, this flag suppresses any lengthy route resolution.
+.IP "RAI_FAMILY" 12
+If set, the ai_family setting should be used as an input hint for interpretting
+the node parameter.
 .IP "ai_family" 12
 Address family for the source and destination address.  Supported families
 are: AF_INET, AF_INET6, and AF_IB.
diff --git a/src/addrinfo.c b/src/addrinfo.c
index 2da35f0..44496cc 100755
--- a/src/addrinfo.c
+++ b/src/addrinfo.c
@@ -56,9 +56,12 @@
 static void ucma_convert_to_ai(struct addrinfo *ai, struct rdma_addrinfo *rai)
 {
 	memset(ai, 0, sizeof *ai);
-	ai->ai_flags  = (rai->ai_flags & RAI_PASSIVE) ? AI_PASSIVE : 0;
-	ai->ai_flags |= (rai->ai_flags & RAI_NUMERICHOST) ? AI_NUMERICHOST : 0;
-	ai->ai_family = rai->ai_family;
+	if (rai->ai_flags & RAI_PASSIVE)
+		ai->ai_flags = AI_PASSIVE;
+	if (rai->ai_flags & RAI_NUMERICHOST)
+		ai->ai_flags |= AI_NUMERICHOST;
+	if (rai->ai_family != AF_IB)
+		ai->ai_family = rai->ai_family;
 
 	switch (rai->ai_qp_type) {
 	case IBV_QPT_RC:
@@ -99,11 +102,45 @@ static void ucma_convert_to_ai(struct addrinfo *ai, struct rdma_addrinfo *rai)
 	ai->ai_next = NULL;
 }
 
+static int ucma_copy_addr(struct sockaddr **dst, socklen_t *dst_len,
+			  struct sockaddr *src, socklen_t src_len)
+{
+	*dst = malloc(src_len);
+	if (!(*dst))
+		return ERR(ENOMEM);
+
+	memcpy(*dst, src, src_len);
+	*dst_len = src_len;
+	return 0;
+}
+
+static int ucma_convert_in6(struct sockaddr_ib **dst, socklen_t *dst_len,
+			    struct sockaddr_in6 *src, socklen_t src_len)
+{
+	*dst = calloc(1, sizeof(struct sockaddr_ib));
+	if (!(*dst))
+		return ERR(ENOMEM);
+
+	(*dst)->sib_family = AF_IB;
+	(*dst)->sib_pkey = 0xFFFF;
+	(*dst)->sib_flowinfo = src->sin6_flowinfo;
+	ib_addr_set(&(*dst)->sib_addr, src->sin6_addr.s6_addr32[0],
+		    src->sin6_addr.s6_addr32[1], src->sin6_addr.s6_addr32[2],
+		    src->sin6_addr.s6_addr32[3]);
+	if (src->sin6_port) {
+		(*dst)->sib_sid = htonll((uint64_t) ntohs(src->sin6_port));
+		(*dst)->sib_sid_mask = htonll((uint64_t) 0x0000FFFF);
+	}
+	(*dst)->sib_scope_id = src->sin6_scope_id;
+
+	*dst_len = sizeof(struct sockaddr_ib);
+	return 0;
+}
+
 static int ucma_convert_to_rai(struct rdma_addrinfo *rai,
 			       struct rdma_addrinfo *hints, struct addrinfo *ai)
 {
-	struct sockaddr *addr;
-	char *canonname;
+	int ret;
 
 	rai->ai_family = ai->ai_family;
 
@@ -133,24 +170,36 @@ static int ucma_convert_to_rai(struct rdma_addrinfo *rai,
 		}
 	}
 
-	addr = malloc(ai->ai_addrlen);
-	if (!addr)
-		return ERR(ENOMEM);
-
-	canonname = ai->ai_canonname ? strdup(ai->ai_canonname) : NULL;
-
-	memcpy(addr, ai->ai_addr, ai->ai_addrlen);
 	if (ai->ai_flags & RAI_PASSIVE) {
-		rai->ai_src_addr = addr;
-		rai->ai_src_len = ai->ai_addrlen;
-		rai->ai_src_canonname = canonname;
+		if (ai->ai_canonname)
+			rai->ai_src_canonname = strdup(ai->ai_canonname);
+
+		if ((hints->ai_flags & RAI_FAMILY) && (hints->ai_family == AF_IB) &&
+		    (hints->ai_flags & RAI_NUMERICHOST)) {
+			ret = ucma_convert_in6((struct sockaddr_ib **) &rai->ai_src_addr,
+					       &rai->ai_src_len,
+					       (struct sockaddr_in6 *) ai->ai_addr,
+					       ai->ai_addrlen);
+		} else {
+			ret = ucma_copy_addr(&rai->ai_src_addr, &rai->ai_src_len,
+					     ai->ai_addr, ai->ai_addrlen);
+		}
 	} else {
-		rai->ai_dst_addr = addr;
-		rai->ai_dst_len = ai->ai_addrlen;
-		rai->ai_dst_canonname = canonname;
+		if (ai->ai_canonname)
+			rai->ai_dst_canonname = strdup(ai->ai_canonname);
+
+		if ((hints->ai_flags & RAI_FAMILY) && (hints->ai_family == AF_IB) &&
+		    (hints->ai_flags & RAI_NUMERICHOST)) {
+			ret = ucma_convert_in6((struct sockaddr_ib **) &rai->ai_dst_addr,
+					       &rai->ai_dst_len,
+					       (struct sockaddr_in6 *) ai->ai_addr,
+					       ai->ai_addrlen);
+		} else {
+			ret = ucma_copy_addr(&rai->ai_dst_addr, &rai->ai_dst_len,
+					     ai->ai_addr, ai->ai_addrlen);
+		}
 	}
-
-	return 0;
+	return ret;
 }
 
 static int ucma_convert_gai(char *node, char *service,
@@ -178,18 +227,6 @@ static int ucma_convert_gai(char *node, char *service,
 	return ret;
 }
 
-static int ucma_copy_ai_addr(struct sockaddr **dst, socklen_t *dst_len,
-			     struct sockaddr *src, socklen_t src_len)
-{
-	*dst = calloc(1, src_len);
-	if (!(*dst))
-		return ERR(ENOMEM);
-
-	memcpy(*dst, src, src_len);
-	*dst_len = src_len;
-	return 0;
-}
-
 int rdma_getaddrinfo(char *node, char *service,
 		     struct rdma_addrinfo *hints,
 		     struct rdma_addrinfo **res)
@@ -216,16 +253,16 @@ int rdma_getaddrinfo(char *node, char *service,
 		rai->ai_qp_type = hints->ai_qp_type;
 		rai->ai_port_space = hints->ai_port_space;
 		if (hints->ai_dst_len) {
-			ret = ucma_copy_ai_addr(&rai->ai_dst_addr, &rai->ai_dst_len,
-						hints->ai_dst_addr, hints->ai_dst_len);
+			ret = ucma_copy_addr(&rai->ai_dst_addr, &rai->ai_dst_len,
+					     hints->ai_dst_addr, hints->ai_dst_len);
 		}
 	}
 	if (ret)
 		goto err;
 
 	if (!rai->ai_src_len && hints && hints->ai_src_len) {
-		ret = ucma_copy_ai_addr(&rai->ai_src_addr, &rai->ai_src_len,
-					hints->ai_src_addr, hints->ai_src_len);
+		ret = ucma_copy_addr(&rai->ai_src_addr, &rai->ai_src_len,
+				     hints->ai_src_addr, hints->ai_src_len);
 		if (ret)
 			goto err;
 	}
