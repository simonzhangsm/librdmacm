Bottom: 09ed451c6b5c30d2dbe0bbedc3379ef8034dc899
Top:    589161ae78e6cb97402984e81f5f917493d82619
Author: Sean Hefty <sean.hefty@intel.com>
Date:   2014-04-16 21:42:06 -0700

rsocket: Check max inline data after creating QP

The ipath provider will ignore the max_inline_size
specified as input into ibv_create_qp and instead
return the size that it supports (which is 0) on
output.

Update the actual inline size returned from create QP,
and check that it meets the minimum requirement for
rsockets.

Signed-off-by: Sean Hefty <sean.hefty@intel.com>


---

diff --git a/src/cma.c b/src/cma.c
index 0dc229e..4fa41ff 100644
--- a/src/cma.c
+++ b/src/cma.c
@@ -321,7 +321,7 @@ err:
 	return ret;
 }
 
-int ucma_init_all(void)
+static int ucma_init_all(void)
 {
 	int i, ret = 0;
 
diff --git a/src/cma.h b/src/cma.h
index a7bab0f..4c991b4 100644
--- a/src/cma.h
+++ b/src/cma.h
@@ -158,7 +158,7 @@ static inline int ERR(int err)
 	return -1;
 }
 
-int ucma_init(void);
+int ucma_init();
 extern int af_ib_support;
 
 #define RAI_ROUTEONLY		0x01000000
diff --git a/src/rsocket.c b/src/rsocket.c
index 30ea55d..8325edf 100644
--- a/src/rsocket.c
+++ b/src/rsocket.c
@@ -860,6 +860,10 @@ static int rs_create_ep(struct rsocket *rs)
 	if (ret)
 		return ret;
 
+	rs->sq_inline = qp_attr->cap.max_inline_size;
+	if (rs->sq_inline < RS_MIN_INLINE)
+		return ERR(EINVAL);
+
 	for (i = 0; i < rs->rq_size; i++) {
 		ret = rs_post_recv(rs);
 		if (ret)
@@ -1491,6 +1495,12 @@ static int ds_create_qp(struct rsocket *rs, union socket_addr *src_addr,
 	if (ret)
 		goto err;
 
+	rs->sq_inline = qp_attr.cap.max_inline_data;
+	if (rs->sq_inline < RS_MIN_INLINE) {
+		ret = ERR(ENOMEM);
+		goto err;
+	}
+
 	ret = ds_add_qp_dest(qp, src_addr, addrlen);
 	if (ret)
 		goto err;
