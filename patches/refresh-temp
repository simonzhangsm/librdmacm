Bottom: f0b4d530a7758f20a79b3abc8f27419ecb1fc961
Top:    82b0aedfaff9c5dc6df2e8b45d95f760cc338281
Author: Sean Hefty <sean.hefty@intel.com>
Date:   2012-08-16 14:23:58 -0700

Refresh of waitall-buggy

---

diff --git a/src/rsocket.c b/src/rsocket.c
index 13fd0da..8c9e847 100644
--- a/src/rsocket.c
+++ b/src/rsocket.c
@@ -1143,7 +1143,7 @@ ssize_t rrecv(int socket, void *buf, size_t len, int flags)
 		if (flags & MSG_PEEK) {
 			// fixme or will peek same data in waitall loop
 			left -= rs_peek(rs, &buf, left);
-			continue;
+			break;
 		}
 
 		for (; left && rs_have_rdata(rs); left -= rsize) {
@@ -1164,12 +1164,13 @@ ssize_t rrecv(int socket, void *buf, size_t len, int flags)
 				buf += end_size;
 				rsize -= end_size;
 				left -= end_size;
+				rs->rbuf_bytes_avail += end_size;
 			}
 			memcpy(buf, &rs->rbuf[rs->rbuf_offset], rsize);
 			rs->rbuf_offset += rsize;
 			buf += rsize;
+			rs->rbuf_bytes_avail += rsize;
 		}
-		rs->rbuf_bytes_avail += len - left; // <- fixme in waitall loop
 
 	} while ((flags & MSG_WAITALL) && (rs->state & rs_connect_rd) && left);
