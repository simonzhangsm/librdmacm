Bottom: 08cdb9a8cfd429d8b0018d91813c88ace4431342
Top:    ac7a8b594dbde179439d51d04b7a4fbafbf49d2a
Author: Sean Hefty <sean.hefty@intel.com>
Date:   2013-06-10 11:14:05 -0700

Refresh of acm_msg

---

diff --git a/configure.ac b/configure.ac
index 3ce7a6e..327f85b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -70,11 +70,6 @@ AC_CHECK_HEADER(valgrind/memcheck.h, [],
 fi
 fi
 
-AC_CHECK_HEADER(infiniband/acm.h,
-	AC_CHECK_MEMBER(struct acm_msg.resolve_data, [],
-		AC_DEFINE(DEFINE_ACM_MSG, 1, [adding ACM message definition]),
-			[#include <infiniband/acm.h>]), [])
-
 AC_CACHE_CHECK(whether ld accepts --version-script, ac_cv_version_script,
     if test -n "`$LD --help < /dev/null 2>/dev/null | grep version-script`"; then
         ac_cv_version_script=yes
diff --git a/src/acm.c b/src/acm.c
index c423bb7..58cea7c 100755
--- a/src/acm.c
+++ b/src/acm.c
@@ -45,19 +45,85 @@
 #include <infiniband/ib.h>
 #include <infiniband/sa.h>
 
-#include <infiniband/acm.h>
+#define ACM_VERSION             1
+
+#define ACM_OP_RESOLVE          0x01
+//#define ACM_OP_ACK              0x80
+
+//#define ACM_STATUS_SUCCESS      0
+//#define ACM_STATUS_ENOMEM       1
+//#define ACM_STATUS_EINVAL       2
+//#define ACM_STATUS_ENODATA      3
+//#define ACM_STATUS_ENOTCONN     5
+//#define ACM_STATUS_ETIMEDOUT    6
+//#define ACM_STATUS_ESRCADDR     7
+//#define ACM_STATUS_ESRCTYPE     8
+//#define ACM_STATUS_EDESTADDR    9
+//#define ACM_STATUS_EDESTTYPE    10
+
+//#define ACM_FLAGS_QUERY_SA      (1<<31)
+#define ACM_FLAGS_NODELAY	(1<<30)
+
+#define ACM_MSG_HDR_LENGTH      16
+#define ACM_MAX_ADDRESS         64
+#define ACM_MSG_EP_LENGTH       72
+/*
+ * Support up to 6 path records (primary and alternate CM paths,
+ * inbound and outbound primary and alternate data paths), plus CM data.
+ */
+#define ACM_MSG_DATA_LENGTH     (ACM_MSG_EP_LENGTH * 8)
+
+struct acm_hdr {
+	uint8_t                 version;
+	uint8_t                 opcode;
+	uint8_t                 status;
+	uint8_t		        data[3];
+	uint16_t                length;
+	uint64_t                tid;
+};
+
+//#define ACM_EP_INFO_NAME        0x0001
+#define ACM_EP_INFO_ADDRESS_IP  0x0002
+#define ACM_EP_INFO_ADDRESS_IP6 0x0003
+#define ACM_EP_INFO_PATH        0x0010
+
+union acm_ep_info {
+	uint8_t                 addr[ACM_MAX_ADDRESS];
+	uint8_t                 name[ACM_MAX_ADDRESS];
+	struct ibv_path_record  path;
+};
+
+#define ACM_EP_FLAG_SOURCE      (1<<0)
+#define ACM_EP_FLAG_DEST        (1<<1)
+
+struct acm_ep_addr_data {
+	uint32_t                flags;
+	uint16_t                type;
+	uint16_t                reserved;
+	union acm_ep_info       info;
+};
 
-#if DEFINE_ACM_MSG
-typedef struct cma_acm_msg {
+/*
+ * Resolve messages with the opcode set to ACM_OP_RESOLVE are only
+ * used to communicate with the local ib_acm service.  Message fields
+ * in this case are not byte swapped, but note that the acm_ep_info
+ * data is in network order.
+ */
+struct acm_resolve_msg {
+	struct acm_hdr          hdr;
+	struct acm_ep_addr_data data[0];
+};
+
+struct acm_msg {
 	struct acm_hdr                  hdr;
 	union{
 		uint8_t                 data[ACM_MSG_DATA_LENGTH];
 		struct acm_ep_addr_data resolve_data[0];
 	};
-} cma_acm_msg_t;
-#else
-typedef struct acm_msg cma_acm_msg_t;
-#endif
+};
+
+
+
 
 static pthread_mutex_t acm_lock = PTHREAD_MUTEX_INITIALIZER;
 static int sock = -1;
@@ -241,7 +307,7 @@ err:
 	rdma_freeaddrinfo(ib_rai);
 }
 
-static void ucma_ib_save_resp(struct rdma_addrinfo *rai, cma_acm_msg_t *msg)
+static void ucma_ib_save_resp(struct rdma_addrinfo *rai, struct acm_msg *msg)
 {
 	struct acm_ep_addr_data *ep_data;
 	struct ibv_path_data *path_data = NULL;
@@ -325,7 +391,7 @@ static int ucma_ib_addr(struct sockaddr *addr, socklen_t len)
 
 void ucma_ib_resolve(struct rdma_addrinfo **rai, struct rdma_addrinfo *hints)
 {
-	cma_acm_msg_t msg;
+	struct acm_msg msg;
 	struct acm_ep_addr_data *data;
 	int ret;
