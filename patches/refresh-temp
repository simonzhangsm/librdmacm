Bottom: 3140a37a0a670a0494c2686793288c824d2df113
Top:    2cfd1213602b08cffdeaa70b35ffe759618c3cec
Author: Sean Hefty <sean.hefty@intel.com>
Date:   2012-12-10 11:33:43 -0800

Refresh of udpong

---

diff --git a/examples/udpong.c b/examples/udpong.c
index 99bcade..12f0e5b 100644
--- a/examples/udpong.c
+++ b/examples/udpong.c
@@ -42,6 +42,7 @@
 #include <unistd.h>
 #include <netinet/in.h>
 #include <netinet/tcp.h>
+#include <arpa/inet.h>
 
 #include <rdma/rdma_cma.h>
 #include <rdma/rsocket.h>
@@ -57,6 +58,7 @@ static int test_size[] = {
 #define TEST_CNT (sizeof test_size / sizeof test_size[0])
 
 enum {
+	msg_op_login,
 	msg_op_start,
 	msg_op_data,
 	msg_op_echo,
@@ -221,12 +223,24 @@ static ssize_t svr_recv(struct message *msg, size_t size,
 static int svr_process(struct message *msg, size_t size,
 		       union socket_addr *addr, socklen_t addrlen)
 {
+	char str[64];
 	ssize_t ret;
 
 	switch (msg->op) {
-	case msg_op_start:
-		memset(&clients[id], 0, sizeof clients[id]);
+	case msg_op_login:
+		if (addr->sa.sa_family == AF_INET) {
+			printf("client login from %s\n",
+			       inet_ntop(AF_INET, &addr->sin.sin_addr.s_addr,
+					 str, sizeof str));
+		} else {
+			printf("client login from %s\n",
+			       inet_ntop(AF_INET6, &addr->sin6.sin6_addr.s6_addr,
+					 str, sizeof str));
+		}
 		msg->id = id++;
+		/* fall through */
+	case msg_op_start:
+		memset(&clients[msg->id], 0, sizeof clients[msg->id]);
 		break;
 	case msg_op_echo:
 		clients[msg->id].recvcnt++;
@@ -264,8 +278,6 @@ static int svr_bind(void)
 	}
 
 	set_options(rs);
-printf("svr bind af %d type %d prot %d port %d\n", res->ai_family, res->ai_socktype, res->ai_protocol,
-		((struct sockaddr_in *) res->ai_addr)->sin_port);
 	ret = rs_bind(rs, res->ai_addr, res->ai_addrlen);
 	if (ret) {
 		perror("rbind");
@@ -341,7 +353,7 @@ static ssize_t client_recv(struct message *msg, size_t size, int timeout)
 	return ret;
 }
 
-static int client_send_recv(struct message *msg, size_t size)
+static int client_send_recv(struct message *msg, size_t size, int timeout)
 {
 	static uint8_t seqno;
 	int ret;
@@ -352,7 +364,7 @@ static int client_send_recv(struct message *msg, size_t size)
 		if (ret != size)
 			return ret;
 
-		ret = client_recv(msg, size, 1);
+		ret = client_recv(msg, size, timeout);
 	} while (ret <= 0 && msg->seqno != seqno);
 
 	seqno++;
@@ -364,21 +376,21 @@ static int run_test(void)
 	int ret, i;
 
 	msg.op = msg_op_start;
-	ret = client_send_recv(&msg, CTRL_MSG_SIZE);
+	ret = client_send_recv(&msg, CTRL_MSG_SIZE, 1000);
 	if (ret != CTRL_MSG_SIZE)
 		goto out;
 
-	msg.op = echo ? htonl(msg_op_echo) : htonl(msg_op_data);
+	msg.op = echo ? msg_op_echo : msg_op_data;
 	gettimeofday(&start, NULL);
 	for (i = 0; i < transfer_count; i++) {
-		ret = echo ? client_send_recv(&msg, transfer_size) :
+		ret = echo ? client_send_recv(&msg, transfer_size, 1) :
 			     client_send(&msg, transfer_size);
 		if (ret != transfer_size)
 			goto out;
 	}
 
 	msg.op = msg_op_end;
-	ret = client_send_recv(&msg, CTRL_MSG_SIZE);
+	ret = client_send_recv(&msg, CTRL_MSG_SIZE, 1);
 	if (ret != CTRL_MSG_SIZE)
 		goto out;
 
@@ -411,14 +423,17 @@ static int client_connect(void)
 	}
 
 	set_options(rs);
-printf("client connect af %d type %d prot %d port %d\n", res->ai_family, res->ai_socktype, res->ai_protocol,
-		((struct sockaddr_in *) res->ai_addr)->sin_port);
 	ret = rs_connect(rs, res->ai_addr, res->ai_addrlen);
 	if (ret) {
 		perror("rconnect");
 		rs_close(rs);
 	}
 
+	msg.op = msg_op_login;
+	ret = client_send_recv(&msg, CTRL_MSG_SIZE, 1000);
+	if (ret == CTRL_MSG_SIZE)
+		ret = 0;
+
 out:
 	freeaddrinfo(res);
 	return ret;
@@ -438,12 +453,10 @@ static int client_run(void)
 	if (!custom) {
 		for (i = 0; i < TEST_CNT; i++) {
 			init_latency_test(test_size[i]);
-transfer_count = 10;
 			run_test();
 		}
 		for (i = 0; i < TEST_CNT; i++) {
 			init_bandwidth_test(test_size[i]);
-transfer_count = 10;
 			run_test();
 		}
 	} else {
