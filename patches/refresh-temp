Bottom: c4d4709d52e2de492239ded2a4b74e4ebde0db7a
Top:    a51fe46dbaa58743e3254a4ef2288b4490ff5d13
Author: Sean Hefty <sean.hefty@intel.com>
Date:   2012-12-18 15:54:44 -0800

Refresh of dsocket

---

diff --git a/docs/rsocket b/docs/rsocket
index 4192450..f453c1b 100644
--- a/docs/rsocket
+++ b/docs/rsocket
@@ -220,4 +220,60 @@ A service thread is used to process messages received on the UDP socket.  This
 thread updates the rsocket lookup tables with the remote QPN and path record
 data.  The service thread forwards data received on the UDP socket to an
 rsocket QP.  After the remote QPN and path records have been resolved, datagram
-communication between two nodes are done over the UD QP.
\ No newline at end of file
+communication between two nodes are done over the UD QP.
+
+UDP Message Format
+------------------
+Rsockets uses messages exchanged over UDP sockets to resolve remote QP numbers.
+If a user sends a datagram to a remote service and the local rsocket is not
+yet configured to send directly to a remote UD QP, the user data is sent over
+a UDP socket with the following header inserted before the user data. 
+
+struct ds_udp_header {
+	uint32_t	  tag;
+	uint8_t		  version;
+	uint8_t		  op;
+	uint8_t		  length;
+	uint8_t		  reserved;
+	uint32_t	  qpn;  /* lower 8-bits reserved */
+	union {
+		uint32_t  ipv4;
+		uint8_t   ipv6[16];
+	} addr;
+};
+
+Tag - Marker used to help identify that the UDP header is present.
+#define DS_UDP_TAG 0x55555555
+
+Version - IP address version, either 4 or 6
+Op - Indicates message type, used to control the receiver's operation.
+     Valid operations are RS_OP_DATA and RS_OP_CTRL.  Data messages
+     carry user data, while control messages are used to reply with the
+     local QP number.
+Length - Size of the UDP header.
+QPN - UD QP number associated with sender's IP address and port.
+      The sender's address and port is extracted from the received UDP
+      datagram.
+Addr - Target IP address of the sent datagram.
+
+Once the remote QP information has been resolved, data is sent directly
+between UD QPs.  The following header is inserted before any user data that
+is transferred over a UD QP.
+
+struct ds_header {
+	uint8_t		     version;
+	uint8_t		     length;
+	uint16_t	     port;
+	union {
+		uint32_t     ipv4;
+		struct {
+			uint32_t flowinfo;
+			uint8_t  addr[16];
+		} ipv6;
+	} addr;
+};
+
+Verion - IP address version
+Length - Size of the header
+Port - Associated source address UDP port
+Addr - Associated source IP address 
\ No newline at end of file
diff --git a/src/rsocket.c b/src/rsocket.c
index 42a28d2..954e42b 100644
--- a/src/rsocket.c
+++ b/src/rsocket.c
@@ -405,11 +405,6 @@ static int rs_modify_svcs(struct rsocket *rs, int svcs)
 	ret = rdma_seterrno(msg.status);
 	if (svc_cnt)
 		goto unlock;
-//	if (ret && !svc_cnt)
-//		goto join;
-//
-//	pthread_mutex_unlock(&mut);
-//	return ret;
 
 	pthread_join(svc_id, NULL);
 closepair:
@@ -420,29 +415,6 @@ unlock:
 	return ret;
 }
 
-//static void rs_remove_from_svc(struct rsocket *rs)
-//{
-//	struct rs_svc_msg msg;
-//	int ret;
-//
-//	pthread_mutex_lock(&mut);
-//	if (svc_cnt) {
-//		msg.op = RS_SVC_REMOVE;
-//		msg.status = EINVAL;
-//		msg.rs = rs;
-//		write(svc_sock[0], &msg, sizeof msg);
-//		read(svc_sock[0], &msg, sizeof msg);
-//	}
-//
-//	if (!svc_cnt) {
-//		pthread_join(svc_id, NULL);
-//		close(svc_sock[0]);
-//		close(svc_sock[1]);
-//	}
-//
-//	pthread_mutex_unlock(&mut);
-//}
-
 static int ds_compare_addr(const void *dst1, const void *dst2)
 {
 	const struct sockaddr *sa1, *sa2;
@@ -1982,11 +1954,6 @@ static int ds_get_cq_event(struct rsocket *rs)
 	return ret;
 }
 
-static int rs_have_rdata(struct rsocket *rs);
-static int ds_can_send(struct rsocket *rs);
-static int rs_poll_all(struct rsocket *rs);
-static int ds_all_sends_done(struct rsocket *rs);
-
 static int ds_process_cqs(struct rsocket *rs, int nonblock, int (*test)(struct rsocket *rs))
 {
 	int ret = 0;
@@ -2833,7 +2800,6 @@ static int rs_poll_arm(struct pollfd *rfds, struct pollfd *fds, nfds_t nfds)
 				else
 					rfds[i].fd = rs->cm_id->channel->fd;
 			} else {
-				printf("%s ready to poll epfd\n", __func__);
 				rfds[i].fd = rs->epfd;
 			}
 			rfds[i].events = POLLIN;
