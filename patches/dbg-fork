Bottom: 30191aa638f3f574e67a71c82fa7771bcc620c52
Top:    5af5ac17fbea4057817c2bc894127f91eade6ffd
Author: Sean Hefty <sean.hefty@intel.com>
Date:   2012-08-21 13:49:59 -0700

debug fork issue


---

diff --git a/src/preload.c b/src/preload.c
index 0645f6d..bfa719b 100644
--- a/src/preload.c
+++ b/src/preload.c
@@ -34,6 +34,7 @@
 #if HAVE_CONFIG_H
 #  include <config.h>
 #endif /* HAVE_CONFIG_H */
+#include <stdio.h>
 
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -239,7 +240,7 @@ void getenv_options(void)
 	if (var)
 		sq_inline = atoi(var);
 
-	var = getenv("RDMAV_FORK_SAFE");
+	var = getenv("RS_FORK_SUPPORT");
 	if (var)
 		fork_support = atoi(var);
 }
@@ -412,12 +413,19 @@ int socket(int domain, int type, int protocol)
 	if (index < 0)
 		return index;
 
+	if ((domain == PF_INET || domain == PF_INET6) &&
+	    (type == SOCK_STREAM) && (!protocol || protocol == IPPROTO_TCP) && fork_support) {
+		printf("skipping rsocket call\n");
+		goto realsock;
+	}
+
 	recursive = 1;
 	ret = rsocket(domain, type, protocol);
 	recursive = 0;
 	if (ret >= 0) {
 		if (fork_support) {
 			rclose(ret);
+realsock:
 			ret = real.socket(domain, type, protocol);
 			if (ret < 0)
 				return ret;
@@ -560,6 +568,7 @@ static void fork_passive(int socket)
 	sin6.sin6_flowinfo = sin6.sin6_scope_id = 0;
 	memset(&sin6.sin6_addr, 0, sizeof sin6.sin6_addr);
 
+	sem_unlink("/rsocket_fork");
 	sem = sem_open("/rsocket_fork", O_CREAT | O_RDWR,
 		       S_IRWXU | S_IRWXG, 1);
 	if (sem == SEM_FAILED) {
diff --git a/src/rsocket.c b/src/rsocket.c
index 4c4821b..52476a2 100644
--- a/src/rsocket.c
+++ b/src/rsocket.c
@@ -156,6 +156,10 @@ struct rsocket {
 	fastlock_t	  cq_lock;
 	fastlock_t	  cq_wait_lock;
 
+	struct rs_msg	  last_ctrl;
+	uint64_t	  bytes_sent;
+	uint64_t	  bytes_received;
+
 	int		  opts;
 	long		  fd_flags;
 	uint64_t	  so_opts;
@@ -816,6 +820,7 @@ static void rs_send_credits(struct rsocket *rs)
 
 	rs->ctrl_avail--;
 	rs->rseq_comp = rs->rseq_no + (rs->rq_size >> 1);
+	rs->last_ctrl.op = rs->rseq_no + rs->rq_size;
 	if (rs->rbuf_bytes_avail >= (rs->rbuf_size >> 1)) {
 		if (!(rs->opts & RS_OPT_SWAP_SGL)) {
 			sge.addr = (uintptr_t) &rs->rbuf[rs->rbuf_free_offset];
@@ -830,6 +835,7 @@ static void rs_send_credits(struct rsocket *rs)
 		ibsge.addr = (uintptr_t) &sge;
 		ibsge.lkey = 0;
 		ibsge.length = sizeof(sge);
+		rs->last_ctrl.data = sge.length;
 
 		rs_post_write(rs, &ibsge, 1,
 			      rs_msg_set(RS_OP_SGL, rs->rseq_no + rs->rq_size),
@@ -845,6 +851,7 @@ static void rs_send_credits(struct rsocket *rs)
 		if (++rs->remote_sge == rs->remote_sgl.length)
 			rs->remote_sge = 0;
 	} else {
+		rs->last_ctrl.data = 0;
 		rs_post_write(rs, NULL, 0,
 			      rs_msg_set(RS_OP_SGL, rs->rseq_no + rs->rq_size), 0, 0, 0);
 	}
@@ -1173,6 +1180,7 @@ ssize_t rrecv(int socket, void *buf, size_t len, int flags)
 
 	} while (left && (flags & MSG_WAITALL) && (rs->state & rs_connect_rd));
 
+	rs->bytes_received += (len - left);
 	fastlock_release(&rs->rlock);
 	return ret ? ret : len - left;
 }
@@ -1289,6 +1297,7 @@ ssize_t rsend(int socket, const void *buf, size_t len, int flags)
 		if (ret)
 			break;
 	}
+	rs->bytes_sent += (len - left);
 	fastlock_release(&rs->slock);
 
 	return (ret && left == len) ? ret : len - left;
