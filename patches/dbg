Bottom: e0b82367be775902f3588a79dd714486d21646b3
Top:    666a13482ed38495f414616597d974158f974a48
Author: Sean Hefty <sean.hefty@intel.com>
Date:   2012-07-18 09:01:43 -0700

debug fork


---

diff --git a/examples/rstream.c b/examples/rstream.c
index befb7c6..545328b 100644
--- a/examples/rstream.c
+++ b/examples/rstream.c
@@ -182,6 +182,7 @@ static void show_perf(void)
 
 static int size_to_count(int size)
 {
+	return 100;
 	if (size >= 1000000)
 		return 100;
 	else if (size >= 100000)
diff --git a/src/cma.c b/src/cma.c
index 5280620..54b804e 100755
--- a/src/cma.c
+++ b/src/cma.c
@@ -48,6 +48,7 @@
 #include <byteswap.h>
 #include <stddef.h>
 #include <netdb.h>
+#include <stdio.h>
 
 #include "cma.h"
 #include <infiniband/driver.h>
@@ -141,6 +142,7 @@ static void ucma_cleanup(void)
 		free(cma_dev_array);
 		cma_dev_cnt = 0;
 	}
+	printf("ucma_cleanup\n");
 }
 
 static int check_abi_version(void)
@@ -214,6 +216,7 @@ int ucma_init(void)
 	if (cma_dev_cnt)
 		return 0;
 
+	printf("ucma_init\n");
 	pthread_mutex_lock(&mut);
 	if (cma_dev_cnt) {
 		pthread_mutex_unlock(&mut);
diff --git a/src/preload.c b/src/preload.c
index f824af3..983ffe1 100644
--- a/src/preload.c
+++ b/src/preload.c
@@ -48,6 +48,7 @@
 #include <netinet/tcp.h>
 #include <unistd.h>
 #include <semaphore.h>
+#include <stdio.h>
 
 #include <rdma/rdma_cma.h>
 #include <rdma/rdma_verbs.h>
@@ -385,6 +386,7 @@ int socket(int domain, int type, int protocol)
 	if (index < 0)
 		return index;
 
+	printf("socket\n");
 	recursive = 1;
 	ret = rsocket(domain, type, protocol);
 	recursive = 0;
@@ -399,6 +401,7 @@ int socket(int domain, int type, int protocol)
 			fd_store(index, ret, fd_rsocket);
 			set_rsocket_options(ret);
 		}
+		printf("socket - %d\n", index);
 		return index;
 	}
 	fd_close(index, &ret);
@@ -430,6 +433,7 @@ int bind(int socket, const struct sockaddr *addr, socklen_t addrlen)
 int listen(int socket, int backlog)
 {
 	int fd;
+	printf("listen %d\n", socket);
 	return (fd_get(socket, &fd) == fd_rsocket) ?
 		rlisten(fd, backlog) : real.listen(fd, backlog);
 }
@@ -454,6 +458,7 @@ int accept(int socket, struct sockaddr *addr, socklen_t *addrlen)
 
 		fd_store(index, ret, type);
 		last_accept = (type == fd_fork) ? index : -1;
+		printf("accept %d\n", socket);
 		return index;
 	} else {
 		last_accept = -1;
@@ -467,14 +472,17 @@ static int connect_fork(int socket, const struct sockaddr *addr, socklen_t addrl
 	uint32_t msg;
 	long flags;
 
+	printf("connect_fork\n");
 	fd = fd_getd(socket);
 	flags = real.fcntl(fd, F_GETFL);
 	real.fcntl(fd, F_SETFL, 0);
 	ret = real.connect(fd, addr, addrlen);
+	printf("connect_fork - real connect %d %s\n", ret, strerror(errno));
 	if (ret)
 		return ret;
 
 	ret = real.recv(fd, &msg, sizeof msg, MSG_PEEK);
+	printf("connect_fork - real recv %d msg %d\n", ret, msg);
 	if ((ret != sizeof msg) || msg) {
 		fd_store(socket, fd, fd_normal);
 		return 0;
@@ -482,10 +490,12 @@ static int connect_fork(int socket, const struct sockaddr *addr, socklen_t addrl
 
 	real.fcntl(fd, F_SETFL, flags);
 	ret = transpose_socket(socket, fd_rsocket);
+	printf("connect_fork - transpose socket %d\n", ret);
 	if (ret < 0)
 		return ret;
 
 	real.close(fd);
+	printf("connect_fork - connecting rsocket");
 	return rconnect(ret, addr, addrlen);
 }
 
@@ -494,6 +504,7 @@ int connect(int socket, const struct sockaddr *addr, socklen_t addrlen)
 	struct sockaddr_in *sin;
 	int fd, ret;
 
+	printf("conect %d\n", socket);
 	switch (fd_get(socket, &fd)) {
 	case fd_fork:
 		return connect_fork(socket, addr, addrlen);
@@ -834,11 +845,15 @@ pid_t fork(void)
 	uint32_t msg;
 
 	init_preload();
+	printf("fork\n");
 	pid = real.fork();
+	printf("fork - pid %d fork_support %d last_accept %d \n",
+		pid, fork_support, last_accept);
 	if (pid || !fork_support || (last_accept < 0) ||
 	    (fd_get(last_accept, &sfd) != fd_fork))
 		goto out;
 
+	printf("fork - switching to rsocket\n");
 	len = sizeof sin6;
 	ret = real.getsockname(sfd, (struct sockaddr *) &sin6, &len);
 	if (ret)
@@ -846,33 +861,42 @@ pid_t fork(void)
 	sin6.sin6_flowinfo = sin6.sin6_scope_id = 0;
 	memset(&sin6.sin6_addr, 0, sizeof sin6.sin6_addr);
 
+	sem_unlink("/rsocket_fork");
 	sem = sem_open("/rsocket_fork", O_CREAT | O_RDWR,
 		       S_IRWXU | S_IRWXG, 1);
+	printf("fork - sem_open\n");
+	printf("fork - sem value %d\n", sem_getvalue(sem, &ret));
 	if (sem == SEM_FAILED)
 		goto out;
 
 	lfd = rsocket(sin6.sin6_family, SOCK_STREAM, 0);
+	printf("fork - rsocket %d\n", lfd);
 	if (lfd < 0)
 		goto sclose;
 
 	param = 1;
 	rsetsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &param, sizeof param);
 
+	printf("fork - waiting for semaphore\n");
 	sem_wait(sem);
 	ret = rbind(lfd, (struct sockaddr *) &sin6, sizeof sin6);
+	printf("fork - rbind %d\n", ret);
 	if (ret)
 		goto lclose;
 
 	ret = rlisten(lfd, 1);
+	printf("fork - rlisten %d\n", ret);
 	if (ret)
 		goto lclose;
 
 	msg = 0;
 	ret = real.write(sfd, &msg, sizeof msg);
+	printf("fork - real write %d\n", ret);
 	if (ret != sizeof msg)
 		goto lclose;
 
 	dfd = raccept(lfd, NULL, NULL);
+	printf("fork - raccept %d %s\n", dfd, strerror(errno));
 	if (dfd < 0)
 		goto lclose;
 
@@ -883,6 +907,7 @@ pid_t fork(void)
 	copysockopts(dfd, sfd, &rs, &real);
 	real.shutdown(sfd, SHUT_RDWR);
 	real.close(sfd);
+	printf("fork - using rsocket\n");
 	fd_store(last_accept, dfd, fd_rsocket);
 
 lclose:
diff --git a/src/rsocket.c b/src/rsocket.c
index ed125b3..1d293f7 100644
--- a/src/rsocket.c
+++ b/src/rsocket.c
@@ -361,7 +361,9 @@ static int rs_init_bufs(struct rsocket *rs)
 	if (!rs->sbuf)
 		return -1;
 
+	printf("rs init bufs cm_id %p pd %p\n", rs->cm_id, rs->cm_id->pd);
 	rs->smr = rdma_reg_msgs(rs->cm_id, rs->sbuf, rs->sbuf_size);
+	printf("rs init bufs - after reg %p\n", rs->smr);
 	if (!rs->smr)
 		return -1;
 
@@ -425,10 +427,12 @@ static int rs_create_ep(struct rsocket *rs)
 
 	rs_set_qp_size(rs);
 	ret = rs_init_bufs(rs);
+	printf("rs create ep init bufs %d\n", ret);
 	if (ret)
 		return ret;
 
 	ret = rs_create_cq(rs);
+	printf("rs create ep - create cq %d\n", ret);
 	if (ret)
 		return ret;
 
@@ -445,6 +449,7 @@ static int rs_create_ep(struct rsocket *rs)
 	qp_attr.cap.max_inline_data = rs->sq_inline;
 
 	ret = rdma_create_qp(rs->cm_id, NULL, &qp_attr);
+	printf("rs create ep - create qp %d\n", ret);
 	if (ret)
 		return ret;
 
@@ -602,16 +607,19 @@ int raccept(int socket, struct sockaddr *addr, socklen_t *addrlen)
 	struct rs_conn_data *creq, cresp;
 	int ret;
 
+	printf("raccept %d\n", socket);
 	rs = idm_at(&idm, socket);
 	new_rs = rs_alloc(rs);
 	if (!new_rs)
 		return ERR(ENOMEM);
 
 	ret = rdma_get_request(rs->cm_id, &new_rs->cm_id);
+	printf("raccept get request %d\n", ret);
 	if (ret)
 		goto err;
 
 	ret = rs_insert(new_rs);
+	printf("raccept insert %d\n", ret);
 	if (ret < 0)
 		goto err;
 
@@ -625,6 +633,7 @@ int raccept(int socket, struct sockaddr *addr, socklen_t *addrlen)
 		rs_set_nonblocking(new_rs, O_NONBLOCK);
 
 	ret = rs_create_ep(new_rs);
+	printf("raccept create ep %d\n", ret);
 	if (ret)
 		goto err;
 
@@ -632,6 +641,7 @@ int raccept(int socket, struct sockaddr *addr, socklen_t *addrlen)
 	param = new_rs->cm_id->event->param.conn;
 	rs_set_conn_data(new_rs, &param, &cresp);
 	ret = rdma_accept(new_rs->cm_id, &param);
+	printf("raccept rdma accept %d\n", ret);
 	if (!ret)
 		new_rs->state = rs_connect_rdwr;
 	else if (errno == EAGAIN || errno == EWOULDBLOCK)
