Bottom: 1d1da945e49647331f04f82a45cc353e9541a6ae
Top:    c3c95597a157fcea6aa3cbdacf6b26631247389b
Author: Sean Hefty <sean.hefty@intel.com>
Date:   2012-09-21 15:38:15 -0700

librdmacm: Set connection information for AF_IB

If an rdma_cm id is associated with AF_IB, then all private
data is exposed to the user.  Format the private data
according to the rdma_cm service annex.

Signed-off-by: Sean Hefty <sean.hefty@intel.com>


---

diff --git a/include/rdma/rdma_cma.h b/include/rdma/rdma_cma.h
index 4c4a057..70f7f6b 100755
--- a/include/rdma/rdma_cma.h
+++ b/include/rdma/rdma_cma.h
@@ -38,6 +38,7 @@
 #include <sys/socket.h>
 #include <infiniband/verbs.h>
 #include <infiniband/sa.h>
+#include <infiniband/ib.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -96,12 +97,14 @@ struct rdma_addr {
 		struct sockaddr		src_addr;
 		struct sockaddr_in	src_sin;
 		struct sockaddr_in6	src_sin6;
+		struct sockaddr_ib	src_ib;
 		struct sockaddr_storage src_storage;
 	};
 	union {
 		struct sockaddr		dst_addr;
 		struct sockaddr_in	dst_sin;
 		struct sockaddr_in6	dst_sin6;
+		struct sockaddr_ib	dst_ib;
 		struct sockaddr_storage dst_storage;
 	};
 	union {
diff --git a/src/acm.c b/src/acm.c
index c9ca5b5..187125f 100755
--- a/src/acm.c
+++ b/src/acm.c
@@ -170,9 +170,6 @@ static int ucma_ib_set_connect(struct rdma_addrinfo *ib_rai,
 {
 	struct ib_connect_hdr *hdr;
 
-	if (rai->ai_family == AF_IB)
-		return 0;
-
 	hdr = calloc(1, sizeof *hdr);
 	if (!hdr)
 		return ERR(ENOMEM);
@@ -183,12 +180,21 @@ static int ucma_ib_set_connect(struct rdma_addrinfo *ib_rai,
 		       &((struct sockaddr_in *) rai->ai_src_addr)->sin_addr, 4);
 		memcpy(&hdr->cma_dst_ip4,
 		       &((struct sockaddr_in *) rai->ai_dst_addr)->sin_addr, 4);
-	} else {
+	} else if (rai->ai_family == AF_INET6) {
 		hdr->ip_version = 6 << 4;
 		memcpy(&hdr->cma_src_ip6,
 		       &((struct sockaddr_in6 *) rai->ai_src_addr)->sin6_addr, 16);
 		memcpy(&hdr->cma_dst_ip6,
 		       &((struct sockaddr_in6 *) rai->ai_dst_addr)->sin6_addr, 16);
+	} else if (rai->ai_family == AF_IB) {
+		hdr->ip_version = 6 << 4;
+		memcpy(&hdr->cma_src_ip6,
+		       &((struct sockaddr_ib *) rai->ai_src_addr)->sib_addr, 16);
+		memcpy(&hdr->cma_dst_ip6,
+		       &((struct sockaddr_ib *) rai->ai_dst_addr)->sib_addr, 16);
+	} else {
+		free(hdr);
+		return ERR(EINVAL);
 	}
 
 	ib_rai->ai_connect = hdr;
diff --git a/src/cma.c b/src/cma.c
index ff9b426..85f32eb 100755
--- a/src/cma.c
+++ b/src/cma.c
@@ -1285,6 +1285,12 @@ static void ucma_copy_conn_param_to_kern(struct cma_id_private *id_priv,
 	if (id_priv->connect_len) {
 		memcpy(dst->private_data, id_priv->connect, id_priv->connect_len);
 		dst->private_data_len = id_priv->connect_len;
+	} else if (id_priv->id.route.addr.src_addr.sa_family == AF_IB) {
+		struct ib_connect_hdr *hdr = (struct ib_connect_hdr *) dst->private_data;
+		hdr->ip_version = 6 << 4;
+		memcpy(&hdr->cma_src_ip6, &id_priv->id.route.addr.src_ib.sib_addr, 16);
+		memcpy(&hdr->cma_dst_ip6, &id_priv->id.route.addr.dst_ib.sib_addr, 16);
+		dst->private_data_len = sizeof(*hdr);
 	}
 
 	if (src) {
diff --git a/src/cma.h b/src/cma.h
index 7135a61..04bea01 100644
--- a/src/cma.h
+++ b/src/cma.h
@@ -170,6 +170,18 @@ void ucma_ib_resolve(struct rdma_addrinfo **rai, struct rdma_addrinfo *hints);
 #define ucma_ib_resolve(x, y)
 #endif
 
+struct ib_connect_hdr {
+	uint8_t  cma_version;
+	uint8_t  ip_version; /* IP version: 7:4 */
+	uint16_t port;
+	uint32_t src_addr[4];
+	uint32_t dst_addr[4];
+#define cma_src_ip4 src_addr[3]
+#define cma_src_ip6 src_addr[0]
+#define cma_dst_ip4 dst_addr[3]
+#define cma_dst_ip6 dst_addr[0]
+};
+
 /* Define path record definition if using older version of libibverbs */
 #ifdef DEFINE_PATH_RECORD
 #define IBV_PATH_RECORD_REVERSIBLE 0x80
