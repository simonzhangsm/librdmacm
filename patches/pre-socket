Bottom: b882ceec6b7499e6a8c762dc8c1c0077c4a86ed2
Top:    108ed67233ea78a253e5631363bd1ff52254a5d8
Author: Sean Hefty <sean.hefty@intel.com>
Date:   2012-05-25 12:42:12 -0700

rs-preload: Handle recursive socket() calls

When ACM support is enabled in the librdmacm, it will attempt to
establish a socket connection to the ACM daemon.  When the rsocket
preload library is in use, this can result in a recursive call
to socket() that results in the library hanging.  The resulting
call stack is:

socket() -> rsocket() -> rdma_create_id() -> ucma_init() ->
socket() -> rsocket() -> rdma_create_id() -> ucma_init()

The second call to ucma_init() hangs because initialization is
still pending.

Fix this by checking for recursive calls to socket() in the preload
library.  When detected, call the real socket() call instead of
directing the call back into rsockets().  Since rsockets is a part
of the librdmacm, it can call rsockets directly if it wants to use
rsockets instead of standard sockets.

This problem and the cause was reported by Chet Murthy <chet@watson.ibm.com>

Signed-off-by: Sean Hefty <sean.hefty@intel.com>


---

diff --git a/src/preload.c b/src/preload.c
index a3ef488..d21389f 100644
--- a/src/preload.c
+++ b/src/preload.c
@@ -325,22 +325,28 @@ void set_rsocket_options(int rsocket)
 
 int socket(int domain, int type, int protocol)
 {
+	static __thread int recursive;
 	int index, ret;
 
+	if (recursive)
+		goto real;
+
 	init_preload();
 	index = fd_open();
 	if (index < 0)
 		return index;
 
+	recursive = 1;
 	ret = rsocket(domain, type, protocol);
+	recursive = 0;
 	if (ret >= 0) {
 		fd_store(index, ret, fd_rsocket);
 		set_rsocket_options(ret);
 		return index;
-	} else {
-		fd_close(index, &ret);
-		return real_socket(domain, type, protocol);
 	}
+	fd_close(index, &ret);
+real:
+	return real_socket(domain, type, protocol);
 }
 
 int bind(int socket, const struct sockaddr *addr, socklen_t addrlen)
