Bottom: d96457fd183426414dda37a6c7fd43ba793f7908
Top:    0da8f3e659527977d6e1ca59cdaa0c341bbccb25
Author: Sean Hefty <sean.hefty@intel.com>
Date:   2012-05-25 12:42:12 -0700

rs-preload: Handle recursive socket() calls

When ACM support is enabled in the librdmacm, it will attempt to
establish a socket connection to the ACM daemon.  When the rsocket
preload library is in use, this can result in a recursive call
to socket() that results in the library hanging.  The resulting
call stack is:

socket() -> rsocket() -> rdma_create_id() -> ucma_init() ->
socket() -> rsocket() -> rdma_create_id() -> ucma_init()

The second call to ucma_init() hangs because initialization is
still pending.

Fix this by checking for recursive calls to socket() in the preload
library.  When detected, call the real socket() call instead of
directing the call back into rsockets().  Since rsockets is a part
of the librdmacm, it can call rsockets directly if it wants to use
rsockets instead of standard sockets.

This problem and the cause was reported by Chet Murthy <chet@watson.ibm.com>

Signed-off-by: Sean Hefty <sean.hefty@intel.com>


---

diff --git a/src/preload.c b/src/preload.c
index a3ef488..d21389f 100644
--- a/src/preload.c
+++ b/src/preload.c
@@ -325,22 +325,28 @@ void set_rsocket_options(int rsocket)
 
 int socket(int domain, int type, int protocol)
 {
+	static __thread int recursive;
 	int index, ret;
 
+	if (recursive)
+		goto real;
+
 	init_preload();
 	index = fd_open();
 	if (index < 0)
 		return index;
 
+	recursive = 1;
 	ret = rsocket(domain, type, protocol);
+	recursive = 0;
 	if (ret >= 0) {
 		fd_store(index, ret, fd_rsocket);
 		set_rsocket_options(ret);
 		return index;
-	} else {
-		fd_close(index, &ret);
-		return real_socket(domain, type, protocol);
 	}
+	fd_close(index, &ret);
+real:
+	return real_socket(domain, type, protocol);
 }
 
 int bind(int socket, const struct sockaddr *addr, socklen_t addrlen)
